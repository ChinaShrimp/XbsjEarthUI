<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="xbsj-labels" content="Earth示例">
    </meta>
    <title>自定义图元-动态双面电子标牌</title>
    <!-- 0 引入js文件 -->
    <script src="../../XbsjEarth/XbsjEarth.js"></script>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0px;
            padding: 0px;
        }
    </style>
</head>

<body>
    <div id="earthContainer" style="width: 100%; height: 100%; background: grey">
    </div>
    <script>
        var earth;
        var bgImagery;

        async function fetJson(filePath) {
            const r = await fetch(filePath);
            if (!r.ok) {
                return undefined;
            }
            const json = await r.json();
            return json;
        }

        async function startup() {
            earth = new XE.Earth('earthContainer', {
                orderIndependentTranslucency: false,
            });

            earth.sceneTree.root = {
                "children": [
                    {
                        "czmObject": {
                            "name": "谷歌影像",
                            "xbsjType": "Imagery",
                            "xbsjImageryProvider": {
                                "XbsjImageryProvider": {
                                    "url": "//mt1.google.cn/vt/lyrs=s&hl=zh-CN&x={x}&y={y}&z={z}&s=Gali",
                                    "srcCoordType": "GCJ02",
                                    "dstCoordType": "WGS84",
                                    "maximumLevel": 21,
                                },
                            }
                        }
                    },
                ]
            };

            function createDynamicPoi({
                earth,
                imageUrl, 
                configUrl,
                position,
                scale = 100,
                color = [1, 1, 1, 1],
            }) {
                var vertexShaderSource = `
                    attribute vec3 position;
                    attribute vec3 normal;
                    attribute vec2 st;
                    attribute vec4 color;
                    attribute float batchId;
                    varying vec3 v_positionEC;
                    varying vec3 v_normalEC;
                    varying vec2 v_st;
                    varying vec4 v_color;
                    void main()
                    {
                        v_positionEC = (czm_modelView * vec4(position, 1.0)).xyz;       // position in eye coordinates
                        v_normalEC = czm_normal * normal;                               // normal in eye coordinates
                        v_st = st;
                        v_color = color;
                        gl_Position = czm_modelViewProjection * vec4(position, 1.0);
                    }
                `;

                var fragmentShaderSource = `
                    varying vec3 v_positionEC;
                    varying vec3 v_normalEC;
                    varying vec2 v_st;
                    varying vec4 v_color;
                    uniform sampler2D u_image;
                    uniform vec4 u_color;
                    uniform vec4 u_customParams; // 用来指定图像的部分区域 x y width height 都在0-1之间，是比例！
                    void main()
                    {
                        vec3 positionToEyeEC = -v_positionEC;
                        vec3 normalEC = normalize(v_normalEC);
                        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);

                        vec4 imageColor = texture2D(u_image, fract(u_customParams.xy + v_st * u_customParams.zw));
                        // imageColor = czm_gammaCorrect(imageColor);
                        vec3 diffuse = imageColor.rgb;
                        float alpha = imageColor.a;

                        diffuse *= v_color.rgb;
                        alpha *= v_color.a;

                        diffuse *= u_color.rgb;
                        alpha *= u_color.a;

                        // gl_FragColor = vec4(czm_inverseGamma(diffuse), alpha);
                        gl_FragColor = vec4((diffuse), alpha);
                    }
                `;

                    //Cesium.Resource.fetchJson('./assets/guangzhu/guangzhu_1.png.json').then(json => {
                const evalString = `
                    Cesium.Resource.fetchJson('${configUrl}').then(json => {
                        const { count, files } = json;
                        if (files.length > 0) {
                            const { width, height } = files[0];
                            p.scale[1] = ${scale} * width;
                            p.scale[2] = ${scale} * height;
                            p._xx_files = files;
                        }
                    });
                `;

                const preUpdateEvalString = `
                    if (p._xx_files) {
                        if (typeof p._xx_i === 'undefined') {
                            p._xx_i = 0;
                        }
                        p._xx_i = (++p._xx_i) % (p._xx_files.length);

                        const {
                            file,
                            // height,
                            offsetU,
                            offsetV,
                            scaleU,
                            scaleV,
                            // width,
                        } = p._xx_files[p._xx_i];
                        p.customParams = [offsetU, 1.0 - (offsetV + scaleV), scaleU, scaleV];
                    }

                    p.rotation[0] = p.earth.camera.rotation[0] + Math.PI*0.5;
                `;

                const config0 = {
                    // "imageUrl": "./assets/guangzhu/guangzhu_1.png",
                    "imageUrl": imageUrl,
                    // "position": [2.174033927183021, 0.10999357244211576, 0],
                    "position": [...position],
                    "scale": [1, 256, 256],
                    "positions": [0, -1, 0, 0, 1, 0, 0, 1, 2, 0, -1, 2, 0, 1, 0, 0, -1, 0, 0, -1, 2, 0, 1, 2],
                    "sts": [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1],
                    "indices": [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7],
                    "customParams": [0, 0, 1, 1],
                    vertexShaderSource,
                    fragmentShaderSource,
                    evalString,
                    pass: Cesium.Pass.TRANSLUCENT,
                    preUpdateEvalString,
                    "renderState": {
                        "cull": {
                            "enabled": true
                        },
                        "polygonOffset": {},
                        "scissorTest": {
                            "rectangle": {}
                        },
                        "depthRange": {},
                        "depthTest": {
                            "enabled": true
                        },
                        "colorMask": {},
                        "depthMask": false,
                        "blending": {
                            "enabled": true,
                            "color": {},
                            "equationRgb": 32774,
                            "equationAlpha": 32774,
                            "functionSourceRgb": 770,
                            "functionDestinationRgb": 771,
                            "functionDestinationAlpha": 771
                        },
                        "stencilTest": {
                            "frontOperation": {},
                            "backOperation": {}
                        },
                        "sampleCoverage": {}
                    },
                    "color": [...color],
                    // "canvasWidth": 128,
                    // "canvasHeight": 226,
                    "autoRegisterEditing": true
                }

                const p = new XE.Obj.CustomPrimitive(earth);
                p.xbsjFromJSON(config0);

                // window.p = p;
                return p;
            }

            const p = createDynamicPoi({
                earth,
                imageUrl: './assets/guangzhu/guangzhu_bai/guangzhu_bai.png',
                configUrl: './assets/guangzhu/guangzhu_bai/guangzhu_bai.png.json',
                position: [2.174033927183021, 0.10999357244211576, 0],
                scale: 1.0,
                color: [1, 1, 1, 1],
            });

            const p2 = createDynamicPoi({
                earth,
                imageUrl: './assets/guangzhu/kuang_bai/kuang02.png',
                configUrl: './assets/guangzhu/kuang_bai/kuang02.png.json',
                position: [2.174033927183021, 0.10999357244211576, 160*2],
                scale: 0.15,
                color: [0.5, 0.5, 0.5, 1],
            });

            const p3 = createDynamicPoi({
                earth,
                imageUrl: './assets/guangzhu/guangzhu_bai/guangzhu_bai.png',
                configUrl: './assets/guangzhu/guangzhu_bai/guangzhu_bai.png.json',
                position: [2.1740604884893173, 0.10997282231122428, 0],
                scale: 1.0,
                color: [1, 1, 1, 1],
            });

            const p4 = createDynamicPoi({
                earth,
                imageUrl: './assets/guangzhu/kuang_bai/kuang02.png',
                configUrl: './assets/guangzhu/kuang_bai/kuang02.png.json',
                position: [2.1740604884893173, 0.10997282231122428, 160*2],
                scale: 0.15,
                color: [0.5, 0.5, 0.5, 1],
            });

            function creatText({
                position,
                scale = 32,
                color = [1, 1, 1, 1]
            }) {
                var vertexShaderSource = `
                    attribute vec3 position;
                    attribute vec3 normal;
                    attribute vec2 st;
                    attribute vec4 color;
                    attribute float batchId;
                    varying vec3 v_positionEC;
                    varying vec3 v_normalEC;
                    varying vec2 v_st;
                    varying vec4 v_color;
                    void main()
                    {
                        v_positionEC = (czm_modelView * vec4(position, 1.0)).xyz;       // position in eye coordinates
                        v_normalEC = czm_normal * normal;                               // normal in eye coordinates
                        v_st = st;
                        v_color = color;
                        gl_Position = czm_modelViewProjection * vec4(position, 1.0);
                    }
                `;

                var fragmentShaderSource = `
                    varying vec3 v_positionEC;
                    varying vec3 v_normalEC;
                    varying vec2 v_st;
                    varying vec4 v_color;
                    uniform sampler2D u_image;
                    uniform vec4 u_color;
                    uniform vec4 u_customParams; // 用来指定图像的部分区域 x y width height 都在0-1之间，是比例！
                    void main()
                    {
                        vec3 positionToEyeEC = -v_positionEC;
                        vec3 normalEC = normalize(v_normalEC);
                        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);

                        vec4 sdfColor = texture2D(u_image, fract(u_customParams.xy + v_st * u_customParams.zw));
                        float distance = sdfColor.r;

                        float _SmoothDelta = 0.02;
                        float _DistanceMark = 0.7;

                        // do some anti-aliasing
                        vec4 imageColor = vec4(1.0, 1.0, 1.0, 1.0);
                        imageColor.a = smoothstep(_DistanceMark - _SmoothDelta, _DistanceMark + _SmoothDelta, distance);

                        //vec4 imageColor = texture2D(u_image, fract(u_customParams.xy + v_st * u_customParams.zw));

                        // imageColor = czm_gammaCorrect(imageColor);
                        vec3 diffuse = imageColor.rgb;
                        float alpha = imageColor.a;

                        diffuse *= v_color.rgb;
                        alpha *= v_color.a;

                        diffuse *= u_color.rgb;
                        alpha *= u_color.a;

                        // gl_FragColor = vec4(czm_inverseGamma(diffuse), alpha);
                        gl_FragColor = vec4((diffuse), alpha);
                    }
                `;

                const evalString = `
                    function setNumber(num) {
                        const offsetU = (num % 32) / 32;
                        const offsetV = (num / 32 | 0) / 32;
                        const scaleU = 1 / 32;
                        const scaleV = 1 / 32;
                        this.customParams = [offsetU, 1.0 - (offsetV + scaleV), scaleU, scaleV];
                        this._xx_i = num;
                    }
                    p.setNumber = setNumber.bind(p);

                    function setFinal(final) {
                        final = final > 1000 ? 1000 : final;
                        final = final < 0 ? 0 : final;
                        this._xx_final = final;
                    }
                    p.setFinal = setFinal.bind(p);

                    p.setNumber(0);
                    p.setFinal(0);
                    setTimeout(() => {
                        p.setNumber(0);
                    }, 0);
                `;

                const preUpdateEvalString = `
                    if (p._xx_i !== p._xx_final) {
                        let add = 1;
                        if (p._xx_final < p._xx_i) {
                            add = -1;
                        }

                        p.setNumber(p._xx_i + add);
                    }

                    p.rotation[0] = p.earth.camera.rotation[0] + Math.PI*0.5;
                `;

                const config0 = {
                    "imageUrl": "./assets/guangzhu/numbers/numbers-sdf.png", // Apps\Examples\assets\guangzhu\numbers\numbers-white.png
                    // "position": [2.174033927183021, 0.10999357244211576, 226*2],
                    "position": [...position],
                    "scale": [1, 32, 32],
                    "positions": [0, -1, 0, 0, 1, 0, 0, 1, 2, 0, -1, 2, 0, 1, 0, 0, -1, 0, 0, -1, 2, 0, 1, 2],
                    "sts": [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1],
                    "indices": [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7],
                    // "customParams": [0, 0, 1, 1],
                    evalString,
                    preUpdateEvalString,
                    vertexShaderSource,
                    fragmentShaderSource,
                    pass: Cesium.Pass.OVERLAY,
                    // pass: Cesium.Pass.OPAQUE,
                    // pass: Cesium.Pass.TRANSLUCENT,
                    "renderState": {
                        "cull": {
                            "enabled": true
                        },
                        "polygonOffset": {
                            enabled: true,
                            factor: -1.0,
                            units: -10.0,
                        },
                        "scissorTest": {
                            "rectangle": {}
                        },
                        "depthRange": {},
                        "depthTest": {
                            "enabled": true
                        },
                        "colorMask": {},
                        "depthMask": false,
                        "blending": {
                            "enabled": true,
                            "color": {},
                            "equationRgb": 32774,
                            "equationAlpha": 32774,
                            "functionSourceRgb": 770,
                            "functionDestinationRgb": 771,
                            "functionDestinationAlpha": 771
                        },
                        "stencilTest": {
                            "frontOperation": {},
                            "backOperation": {}
                        },
                        "sampleCoverage": {}
                    },
                    "color": [...color],
                    // "canvasWidth": 128,
                    // "canvasHeight": 226,
                    "autoRegisterEditing": true
                }

                const p = new XE.Obj.CustomPrimitive(earth);

                p.xbsjFromJSON(config0);

                return p;
            }


            const t1 = creatText({
                position: [2.174033927183021, 0.10999357244211576, 160*2],
                scale: 32,
                color: [1, 1, 0, 1],
            });
            const t2 = creatText({
                position: [2.1740604884893173, 0.10997282231122428, 160*2],
                scale: 32,
                color: [0, 1, 0, 1],
            });

            earth.camera.flyAround([2.174033927183021, 0.10999357244211576, 0], 1650, [0, -0.6, 0]);

        }

        // 1 XE.ready()会加载Cesium.js等其他资源，注意ready()返回一个Promise对象。
        XE.ready().then(startup);
    </script>
</body>

</html>